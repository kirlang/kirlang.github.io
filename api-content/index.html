{"posts":[{"title":"红黑树C语言实现","content":" ","link":"https://kirlang.github.io/D6Ax3YlZ-/"},{"title":"常用hash函数C语言实现","content":" ","link":"https://kirlang.github.io/chang-yong-hash-han-shu-c-yu-yan-shi-xian/"},{"title":"CRC16常见几个标准的算法及C语言实现","content":"CRC16常见的标准有以下几种，被用在各个规范中，其算法原理基本一致，就是在数据的输入和输出有所差异，下边把这些标准的差异列出，并给出C语言的算法实现。 CRC16_CCITT：多项式x16+x12+x5+1（0x1021），初始值0x0000，低位在前，高位在后，结果与0x0000异或 CRC16_CCITT_FALSE：多项式x16+x12+x5+1（0x1021），初始值0xFFFF，低位在后，高位在前，结果与0x0000异或 CRC16_XMODEM：多项式x16+x12+x5+1（0x1021），初始值0x0000，低位在后，高位在前，结果与0x0000异或 CRC16_X25：多项式x16+x12+x5+1（0x1021），初始值0x0000，低位在前，高位在后，结果与0xFFFF异或 CRC16_MODBUS：多项式x16+x15+x2+1（0x8005），初始值0xFFFF，低位在前，高位在后，结果与0x0000异或 CRC16_IBM：多项式x16+x15+x2+1（0x8005），初始值0x0000，低位在前，高位在后，结果与0x0000异或 CRC16_MAXIM：多项式x16+x15+x2+1（0x8005），初始值0x0000，低位在前，高位在后，结果与0xFFFF异或 CRC16_USB：多项式x16+x15+x2+1（0x8005），初始值0xFFFF，低位在前，高位在后，结果与0xFFFF异或 多项式产生： 如x16+x12+x5+1 x16表示第16位为1，x5表示第5位为1 (1 &lt;&lt; 16) | (1 &lt;&lt; 12) | (1 &lt;&lt; 5) | (1) = 0x11021 但是CRC16只取低16位，写成16进制数就是 0x1021 CRC16的算法原理： 1.根据CRC16的标准选择初值CRCIn的值。 2.将数据的第一个字节与CRCIn高8位异或。 3.判断最高位，若该位为 0 左移一位，若为 1 左移一位再与多项式Hex码异或。 4.重复3直至8位全部移位计算结束。 5.重复将所有输入数据操作完成以上步骤，所得16位数即16位CRC校验码。 根据算法原理与标准要求就能简单的写出具体程序： CRC算法参数模型解释： NAME：参数模型名称。 WIDTH：宽度，即CRC比特数。 POLY：生成项的简写，以16进制表示。例如：CRC-32即是0x04C11DB7，忽略了最高位的&quot;1&quot;，即完整的生 成项是0x104C11DB7。 INIT：这是算法开始时寄存器（crc）的初始化预置值，十六进制表示。 REFIN：待测数据的每个字节是否按位反转，True或False。 REFOUT：在计算后之后，异或输出之前，整个数据是否按位反转，True或False。 XOROUT：计算结果与此参数异或后得到最终的CRC值。 Alias：别名及其应用范围。 ","link":"https://kirlang.github.io/crc16-chang-jian-ji-ge-biao-zhun-de-suan-fa-ji-c-yu-yan-shi-xian/"},{"title":"双链表容器设计与实现","content":"节点和链表定义 节点和链表初始化 链表插入算法 链表删除算法 链表查询算法 链表顺序访问宏定义 ","link":"https://kirlang.github.io/shuang-lian-biao-rong-qi-she-ji-yu-shi-xian/"},{"title":"C/C++ 宏定义技巧","content":"转字符串宏 连接符号宏 可变参数宏 ","link":"https://kirlang.github.io/cc-hong-ding-yi-ji-qiao-zhi-he/"},{"title":"c++union对象使用技巧","content":"底层原理 所需技术 1、代码案例 2、运行 3、修复 4、运行 5、修复 ","link":"https://kirlang.github.io/cunion-dui-xiang-shi-yong-ji-qiao/"},{"title":"c++函数委托模板实现","content":"底层原理： 所需技术： 1、静态函数指针申明 函数指针类型申明 或者 2、成员函数指针声明 或者 3、可变模板参数 4、手动构造类对象 5、委托模板基类 6、静态函数委托模板 7、成员函数委托模板 8、函数委托统一模板 ","link":"https://kirlang.github.io/chan-shu-wei-tuo-mo-ban-shi-xian/"}]}